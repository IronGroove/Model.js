{"name":"Model.js","tagline":"Models for javascripting","body":"# Models for javascripting\r\n\r\nModel.js introduces new simple way of maintaining model layers in javascript applications. As of version v0.1, this library provides handy and readable data describing, data validation capabilities and event machinery for bindings on major data lifecycle events.\r\n\r\n*All this is better explained by example.*\r\n\r\n```javascript\r\n// DESCRIBE\r\nvar Note = new Model('Note', function () {\r\n  this.attr('id!', 'number');\r\n  this.attr('title+', 'string', 'nonempty');\r\n  this.attr('lang+', 'string', [ 'in', ['en','uk','ru']]);\r\n  this.attr('text', 'string');\r\n});\r\n\r\nNote.bind('initialize', function () {\r\n  if (!this.data.lang) {\r\n    this.set('lang', 'en');\r\n  }\r\n});\r\n\r\n// AMPLIFY\r\nNote.prototype.save = function () {\r\n  var note = this,\r\n    data = note.data();\r\n  window.localStorage.setItem(\"Note\"+data.id, JSON.stringify(data));\r\n  note._persist();\r\n}\r\n\r\nvar note = new Note({ title: \"Hello\" });\r\n\r\nassert( note.isNew );\r\nassert( note.data.title == \"Hello\" );\r\nassert( note.data.lang == \"en\" );\r\nassert( note.hasChanged );\r\nassert( note.isValid );\r\n\r\n// INTEGRATE\r\nnote.bind('change', function (changes) {\r\n  if (changes.title) {\r\n    document.getElementById('note-title').innerHTML = changes.title;\r\n  }\r\n});\r\n\r\nnote.data.title = '';\r\nassert( !note.isValid );\r\nassert( note.errors.title == Model.errCodes.EMPTY );\r\n\r\nnote.data.title = \"Let's go!\";\r\n\r\n// Designed to be Django-style.\r\nif (note.isValid) {\r\n  note.save();\r\n}\r\n\r\nassert( !note.isNew );\r\n```\r\n\r\n*And now, all these features in details.*\r\n\r\n\r\n## Defining models (describing data)\r\n\r\n`new Model` receives two arguments and creates new model classes. These arguments are the name of the model class being created and the configuration function.\r\n\r\nConfiguration functions are actually sugar that allows to configure classes in a fancy manner. Currently there's only `attr` method in configuration function context and it is used to define attributes.\r\n\r\n`attr` may receive multiple arguments. The 1st argument should be string name of the attribute. That name may end with a plus sign which is used to mark attributes that should have value (namely, required attributes) or exclamation mark which indicates primary key (of course, primary key is required too).\r\n\r\nAll following arguments should be _validators_ for the attribute's value.\r\n\r\n\r\n### Validators\r\n\r\nValidator is a simple function receiving value to validate and returning some string error code when value is invalid. It may also receive other arguments though. Validators defined on attributes are run when `instance.isValid` or `instance.errors` is called.\r\n\r\n```javascript\r\nfunction minLength(value, minLen) {\r\n  return (typeof value === 'string' && value.length >= minLen) ? 'tooshort' : undefined;\r\n}\r\n```\r\n\r\nThere is a number of predefined common validators in Model.js (`number`, `string`, `boolean`, `nonnull`, `nonempty` and `in`) so that when defining attributes on new models, you may just write their names.\r\n\r\n```javascript\r\nvar Note = new Model('Note', function () {\r\n  this.attr('id!', 'number');\r\n  this.attr('title', 'nonnull', 'string', 'nonempty');\r\n  this.attr('lang', 'nonnull', 'string', [ 'in', ALLOWED_LANGUAGES ]);\r\n  this.attr('text', function (value) {\r\n  \treturn typeof value === 'string';\r\n  });\r\n});\r\n```\r\nWhen you want to pass additional arguments to validator, like checking if `lang` value is one of the ALLOWED_LANGUAGES, add that validator to an attribute in an array form as in example above.\r\n\r\nCommon reusable validators, such as mentioned `number`, `string` and other, may be registed with `Model.registerValidator` which received two arguments, the name and the function.\r\n\r\n```javascript\r\nModel.registerValidator('maxLen', function maxLength(value, maxLen) {\r\n  return (typeof value === 'string' && value.length <= minLen) ? 'toolong' : undefined;\r\n});\r\n```\r\n\r\nTo say, attribute names with a plus sign at the end are just shortcuts to avoid that long unpretty _'nonnull'_ validator names. But you may still use _'nonnull'_ if you like it more.\r\n\r\n\r\n## Working with data\r\n\r\n### Instance\r\n\r\nInstances are created with `new Note({…})` form and all instances tend to be persisted on creation.\r\n\r\nIf you're creating absolutely new instance which is not yet persisted (e.g. from data taken right out of an HTML form) you should use `new Note(false, {…})` form where 1st argument is an explicit persistance flag. You may set it to `true`, but there's no need to do so as `new Note(true, {…})` actually produces same result as `new Note({…})`.\r\n\r\nPersisting on creation will fail silently when data provided has no PK { attrName: value} pair but a model class has a primary key defined.\r\n\r\n\r\n### Setters\r\n\r\nThere are two kinds of setters. There are those which trigger change event on instances and those which don't.\r\n\r\n```javascript\r\n// These two setters trigger it\r\nnote.data.title = \"Hi there\";\r\nnote.data = { title: \"Hi there\", lang: \"en\" };\r\n\r\n// … and these two don't.\r\nnote.set('title', \"Hi there\");\r\nnote.set({ title: \"Hi there\", lang: \"en\" });\r\n```\r\n\r\n\r\n### Getters\r\n\r\n`note.data.title` returns value of a single attribute.\r\n\r\n`note.data.get('title', 'lang')` returns specific attributes' values in an object of { attrName: value } pairs.\r\n\r\nTo get whole instace's data use `note.data()` or `note.get()`.\r\n\r\n\r\n### Changes\r\n\r\n`note.hasChanged` tells if instance data has been changed since its latest persisting.\r\n\r\n`note.isNew` well yes, it tells if instance is new (has never been persisted).\r\n\r\n`note.isPersisted` tells whether instance changes are persisted and there are no pending changes to persist.\r\n\r\n`note._revert()` is rolling back all changes made on instance data and triggers `revert` event that application may bind handlers on.\r\n\r\n`note._persist()` is persisting changes made on instance data and triggers `persist` event. This method should be called right after application has made sure that data is persisted.\r\n\r\nTo say, in web environment when persisting data with ajax, `_persist` should be called in success stage and _revert` may be called if request fails and it makes sense for the application.\r\n\r\n```javascript\r\nNote.prototype.save = function () {\r\n  var note = this;\r\n  return $.ajax({\r\n    type: 'PUT',\r\n    url: '/notes/'+note.data.id,\r\n    data: note.data(),\r\n    dataType: 'json'\r\n  }).done(function (json) {\r\n    note._persist();\r\n  });\r\n}\r\n```\r\n\r\n\r\n## Events\r\n\r\n`initialize` is triggered on instance creation, right on `var note = new Note;`.\r\n\r\n`change` is triggered every time attributes' values are changed like `note.data.title = \"Hi\"` or like `note.data = {…}`.\r\n\r\n`change` is not triggered though when setting values on attributes with `set` method.\r\n\r\nHandlers bound to `change` event receive data object of changes made (see example below).\r\n\r\n`persist` and `revert` are triggered when their corresponding methods are called.\r\n\r\nYou may bind event handlers either on model classes so that they subsequently refer to all instances or on specific instances.\r\n\r\n```javascript\r\nNote.bind('initialize', function () {\r\n  if (!this.data.lang) {\r\n    this.set('lang', 'en');\r\n  }\r\n});\r\n\r\nnote.bind('change', function (changes) {\r\n  if (changes.title) {\r\n    document.getElementById('note-title').innerHTML = changes.title;\r\n  }\r\n});\r\n```\r\n","google":"UA-38290306-3","note":"Don't delete this file! It's used internally to help with page regeneration."}